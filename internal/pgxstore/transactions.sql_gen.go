// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package pgxstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const CreateInitUserTransaction = `-- name: CreateInitUserTransaction :one
INSERT INTO transactions (user_id, old_balance, change, new_balance, type, created_at)
VALUES ($1, 0,  0, 0, 'INIT', now())
RETURNING id, order_number, user_id, old_balance, change, new_balance, type, created_at
`

func (q *Queries) CreateInitUserTransaction(ctx context.Context, userID uuid.UUID) (*Transaction, error) {
	row := q.db.QueryRow(ctx, CreateInitUserTransaction, userID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.UserID,
		&i.OldBalance,
		&i.Change,
		&i.NewBalance,
		&i.Type,
		&i.CreatedAt,
	)
	return &i, err
}

const CreateTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (order_number, user_id, old_balance, change, new_balance, type, created_at)
VALUES ($1, $2,  $3, $4, $5, $6, now())
RETURNING id, order_number, user_id, old_balance, change, new_balance, type, created_at
`

type CreateTransactionParams struct {
	OrderNumber *string         `db:"order_number" json:"order_number"`
	UserID      uuid.UUID       `db:"user_id" json:"user_id"`
	OldBalance  decimal.Decimal `db:"old_balance" json:"old_balance"`
	Change      decimal.Decimal `db:"change" json:"change"`
	NewBalance  decimal.Decimal `db:"new_balance" json:"new_balance"`
	Type        TransactionType `db:"type" json:"type"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, CreateTransaction,
		arg.OrderNumber,
		arg.UserID,
		arg.OldBalance,
		arg.Change,
		arg.NewBalance,
		arg.Type,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.UserID,
		&i.OldBalance,
		&i.Change,
		&i.NewBalance,
		&i.Type,
		&i.CreatedAt,
	)
	return &i, err
}

const GetLastUserTransaction = `-- name: GetLastUserTransaction :one
SELECT id, order_number, user_id, old_balance, change, new_balance, type, created_at FROM transactions WHERE user_id=$1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetLastUserTransaction(ctx context.Context, userID uuid.UUID) (*Transaction, error) {
	row := q.db.QueryRow(ctx, GetLastUserTransaction, userID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.UserID,
		&i.OldBalance,
		&i.Change,
		&i.NewBalance,
		&i.Type,
		&i.CreatedAt,
	)
	return &i, err
}

const GetTransactions = `-- name: GetTransactions :many
SELECT id, order_number, user_id, old_balance, change, new_balance, type, created_at
    FROM transactions as t
    WHERE
        (NOT $1::boolean OR t.user_id = $2) AND
        (NOT $3::boolean OR t.type = $4)
    ORDER BY created_at DESC
`

type GetTransactionsParams struct {
	IsUserID bool            `db:"is_user_id" json:"is_user_id"`
	UserID   uuid.UUID       `db:"user_id" json:"user_id"`
	IsType   bool            `db:"is_type" json:"is_type"`
	Type     TransactionType `db:"type" json:"type"`
}

func (q *Queries) GetTransactions(ctx context.Context, arg GetTransactionsParams) ([]*Transaction, error) {
	rows, err := q.db.Query(ctx, GetTransactions,
		arg.IsUserID,
		arg.UserID,
		arg.IsType,
		arg.Type,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.UserID,
			&i.OldBalance,
			&i.Change,
			&i.NewBalance,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserWithdrawalsSum = `-- name: GetUserWithdrawalsSum :one
SELECT COALESCE(SUM(change),0)::DECIMAL(32, 18) as withdrawals FROM transactions WHERE user_id=$1 and type='WITHDRAW'
`

func (q *Queries) GetUserWithdrawalsSum(ctx context.Context, userID uuid.UUID) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, GetUserWithdrawalsSum, userID)
	var withdrawals decimal.Decimal
	err := row.Scan(&withdrawals)
	return withdrawals, err
}
